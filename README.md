# ITMO-System-Design

## Разработка

### Poetry

1) ```poetry env use python3.12```
2) ```poetry install ```
3) Чтобы добавить пакет: ```poetry add <package-name>```

### Pre-commit hooks

1) ```pre-commit install```
2) При падении,
   поправьте ошибки и вновь сделайте коммит.\
   Обратите внимание, что часть ошибок исправляются автоматически.
3) Запустить хуки без коммита на все файлы: ```pre-commit run -a```

## Тестирование

Чтобы запустить тесты, вызовите:

```sh
poetry run pytest -vv --showlocals
```

## Документация

1) Docstrings создаются автоматически с помощью пакета [py-doq](https://github.com/heavenshell/py-doq),
   запускаемого прекомитом.\
   К сожалению, ```py-doc``` не умеет создавать docstrings для публичных модулей, поэтому необходимо создать их самому
2) С помощью [Sphinx](https://sphinx-ru-ng.readthedocs.io/_/downloads/ru/latest/pdf/), поддерживается
   пользовательская [Markdown документация](./docs/build/markdown/index.md)

### Sphinx

Если хотим обновить пользовательскую документацию

1) Для обновления ```source``` файлов ```Sphinx``` в корне проекта запускаем:
   ```sphinx-apidoc -f -o ./docs/source ./cli```
2) Создание новой версии ```Markdown```: ```cd docs && make markdown```

## Запуск

```
poerty install
python3 main.py
```

___

# Обратная связь команды №3

## Архитектура

Диаграмма классов выглядит понятно и логично. Названия файлов в реализации соответствуют диаграмме, что упрощает процесс
вникания в код. Однако из-за отсутствия исходников диаграммы классов для нас не было возможным расширить диаграмму
классов новыми классами команд.

Неудобным показалось то, что не сразу понятно, где находится main, так как лежит вне папки src и не указан в
архитектуре. Тем не менее его легко найти, если прочитать инструкцию по запуску.

## Реализация

Добавлять новые команды ls и cd оказалось просто, по аналогии с реализованными командами логично пишутся новые. Добавить
обработку строки от пользователя в парсере тоже интуитивно

#### Удобные моменты:

1. **Чистота и структура кода:** Код организован в классы и использует методы, что способствует пониманию и
   масштабируемости. Это облегчает поддержку и расширение функционала.
2. **Докстринг:** Комментарии отражают суть, особенно для реализаций команд.
3. **Использование типов:** Аннотации типов (например,
   ```def parse(self, cli_input: str) -> list[base_command.BaseCommand]```) делают код более понятным и помогают
   избежать ошибок.
4. **Обработка ошибок:** Код включает создание пользовательского исключения ```InvalidCommandError```, что позволяет
   более
   четко управлять ошибками, связанными с недопустимыми командами.
5. **Unit тесты:** Каждый класс сопровождается своей пачкой юнит тестов, что упрощает улучшения кода, проверяя что
   ничего не
   сломалось, а если сломалось, то где именно

#### Неудобные моменты:

1. Метод ```parse``` стоит разбить на несколько с учетом логики действий, например вынести ```match input_cmd:``` в
   отдельную функцию
2. Для больших публичных методов возможно стоит написать более развернутый комментарий с подробностями о входных и
   выходных аргументах
3. ```executor_test.py``` содержит в себе все интересные тесты, из-за чего довольно большой. Стоит разбить на несколько
   файлов интеграционных тестов по логике (например simple, pipe, errors, invalid_arguments)

В целом проект отлично реализован, недочеты довольно незначительные и субъективные, разобраться было несложно
