# ITMO-System-Design

## Разработка

### Poetry

1) ```poetry env use python3.12```
2) ```poetry install ```
3) Чтобы добавить пакет: ```poetry add <package-name>```

### Pre-commit hooks

1) ```pre-commit install```
2) При падении,
   поправьте ошибки и вновь сделайте коммит.\
   Обратите внимание, что часть ошибок исправляются автоматически.
3) Запустить хуки без коммита на все файлы: ```pre-commit run -a```

## Тестирование

Чтобы запустить тесты, вызовите:

```sh
poetry run pytest -vv --showlocals
```

## Документация

1) Docstrings создаются автоматически с помощью пакета [py-doq](https://github.com/heavenshell/py-doq),
   запускаемого прекомитом.\
   К сожалению, ```py-doc``` не умеет создавать docstrings для публичных модулей, поэтому необходимо создать их самому
2) С помощью [Sphinx](https://sphinx-ru-ng.readthedocs.io/_/downloads/ru/latest/pdf/), поддерживается
   пользовательская [Markdown документация](./docs/build/markdown/index.md)

### Sphinx

Если хотим обновить пользовательскую документацию

1) Для обновления ```source``` файлов ```Sphinx``` в корне проекта запускаем:
   ```sphinx-apidoc -f -o ./docs/source ./cli```
2) Создание новой версии ```Markdown```: ```cd docs && make markdown```

## Запуск

```
poetry install
python3 main.py
```

## Мотивация выбора библиотек разработки
#### Стандартная библиотека `re` для парсинга регулярных выражений в Python

Библиотека `re` является стандартной библиотекой Python для работы с регулярными выражениями и имеет несколько преимуществ:

- **Простота использования**: Библиотека `re` предоставляет интуитивно понятный интерфейс для создания и использования регулярных выражений, что делает её доступной даже для новичков.
- **Широкие возможности**: Она поддерживает множество функций, таких как поиск, замена и разбиение строк, что позволяет решать разнообразные задачи парсинга.
- **Оптимизация производительности**: Библиотека `re` написана на C и оптимизирована для быстрого выполнения, что делает её эффективной для обработки больших объемов данных.

#### Автоматизированное создание `docstrings` с помощью `py-docstrings`

`py-docstrings` — это инструмент, который упрощает создание и управление `docstrings` в коде Python. Его преимущества включают:

- **Автоматизация**: Позволяет автоматически генерировать docstrings для функций и классов, что экономит время разработчиков.
- **Стандартизация**: Использование `py-docstrings` помогает поддерживать единый стиль написания документации, что делает код более читаемым и понятным.
- **Интеграция с инструментами**: Сгенерированные `docstrings` используются другими инструментами такими как `Sphinx`, для создания документации проекта на базе `docstrings`.

#### Автоматизированное создание документации проекта с помощью `Sphinx`

Sphinx — это мощный инструмент для создания документации, который предлагает множество преимуществ:

- **Гибкость**: Sphinx поддерживает различные форматы вывода, включая HTML и PDF, что позволяет легко адаптировать документацию под разные нужды.
- **Поддержка расширений**: Sphinx имеет множество расширений, которые добавляют функциональность, такую как автоматическая генерация документации из docstrings.
- **Удобство использования**: Он позволяет легко организовывать и структурировать документацию, что делает её более доступной для пользователей.

#### Аналоги

Существуют и другие инструменты для работы с документацией и регулярными выражениями в Python, например:

- **Docstring генераторы**: Такие как `pydoc` и `doctrine`, которые также помогают в создании документации, но могут иметь разные подходы и функциональность. Однако `Sphinx` выглядит самым популярным решением.
- **Библиотеки для регулярных выражений**: Например, `regex`, которая предлагает более расширенные возможности по сравнению с `re`, включая поддержку дополнительных синтаксических конструкций. 
  Однако в данном проекте хватает функциональности `re`.

Таким образом, выбор `re` для парсинга регулярных выражений, использование `py-docstrings` для упрощения документации и применение `Sphinx` для её генерации создают мощный и эффективный инструментальный набор для разработчиков на Python.

___

## Обратная связь команды №3

### Архитектура

Диаграмма классов выглядит понятно и логично. Названия файлов в реализации соответствуют диаграмме, что упрощает процесс
вникания в код. Однако из-за отсутствия исходников диаграммы классов для нас не было возможным расширить диаграмму
классов новыми классами команд.

Неудобным показалось то, что не сразу понятно, где находится main, так как лежит вне папки src и не указан в
архитектуре. Тем не менее его легко найти, если прочитать инструкцию по запуску.

### Реализация

Добавлять новые команды ls и cd оказалось просто, по аналогии с реализованными командами логично пишутся новые. Добавить
обработку строки от пользователя в парсере тоже интуитивно

#### Удобные моменты:

1. **Чистота и структура кода:** Код организован в классы и использует методы, что способствует пониманию и
   масштабируемости. Это облегчает поддержку и расширение функционала.
2. **Докстринг:** Комментарии отражают суть, особенно для реализаций команд.
3. **Использование типов:** Аннотации типов (например,
   ```def parse(self, cli_input: str) -> list[base_command.BaseCommand]```) делают код более понятным и помогают
   избежать ошибок.
4. **Обработка ошибок:** Код включает создание пользовательского исключения ```InvalidCommandError```, что позволяет
   более
   четко управлять ошибками, связанными с недопустимыми командами.
5. **Unit тесты:** Каждый класс сопровождается своей пачкой юнит тестов, что упрощает улучшения кода, проверяя что
   ничего не
   сломалось, а если сломалось, то где именно

#### Неудобные моменты:

1. Метод ```parse``` стоит разбить на несколько с учетом логики действий, например вынести ```match input_cmd:``` в
   отдельную функцию
2. Для больших публичных методов возможно стоит написать более развернутый комментарий с подробностями о входных и
   выходных аргументах
3. ```executor_test.py``` содержит в себе все интересные тесты, из-за чего довольно большой. Стоит разбить на несколько
   файлов интеграционных тестов по логике (например simple, pipe, errors, invalid_arguments)

В целом проект отлично реализован, недочеты довольно незначительные и субъективные, разобраться было несложно
